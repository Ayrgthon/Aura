#!/usr/bin/env python3
"""
Aura - Asistente de IA con Voz y MCP
Soporta Google Gemini y Ollama con herramientas MCP
"""

import os
import asyncio
import warnings
from client import AuraClient
from engine.voice.hear import initialize_recognizer, listen_for_command

# Silenciar warnings
warnings.filterwarnings("ignore")

class AuraAssistant:
    def __init__(self):
        """Inicializa el asistente Aura"""
        self.client = None
        self.voice_recognizer = None
        
    def setup_model(self):
        """Configura el modelo LLM a usar"""
        print("ü§ñ Configuraci√≥n de Modelo LLM")
        print("=" * 50)
        print("Modelos disponibles:")
        print("1. üü¢ Google Gemini (gemini-2.0-flash-exp)")
        print("2. ü¶ô Ollama (qwen2.5-coder:7b)")
        print("3. üõ†Ô∏è  Personalizado")
        
        while True:
            try:
                choice = input("\nSelecciona un modelo (1-3): ").strip()
                
                if choice == "1":
                    # Google Gemini
                    model_type = "gemini"
                    model_name = "gemini-2.0-flash-exp"
                    print(f"‚úÖ Seleccionado: Google Gemini ({model_name})")
                    break
                    
                elif choice == "2":
                    # Ollama
                    model_type = "ollama"
                    model_name = "qwen2.5-coder:7b"
                    print(f"‚úÖ Seleccionado: Ollama ({model_name})")
                    break
                    
                elif choice == "3":
                    # Personalizado
                    print("\nConfiguraci√≥n personalizada:")
                    model_type = input("Tipo de modelo (gemini/ollama): ").strip().lower()
                    
                    if model_type not in ["gemini", "ollama"]:
                        print("‚ùå Tipo de modelo no v√°lido")
                        continue
                        
                    if model_type == "gemini":
                        print("Ejemplos: gemini-1.5-flash, gemini-1.5-pro, gemini-2.0-flash-exp")
                        model_name = input("Nombre del modelo: ").strip()
                    else:
                        print("Ejemplos: qwen2.5-coder:7b, llama3.2:latest, codellama:latest")
                        model_name = input("Nombre del modelo: ").strip()
                    
                    if not model_name:
                        print("‚ùå Nombre de modelo no puede estar vac√≠o")
                        continue
                        
                    print(f"‚úÖ Configuraci√≥n personalizada: {model_type.upper()} ({model_name})")
                    break
                    
                else:
                    print("‚ùå Opci√≥n no v√°lida. Selecciona 1, 2 o 3.")
                    
            except KeyboardInterrupt:
                print("\nüëã ¬°Hasta luego!")
                exit(0)
        
        return model_type, model_name
    
    def setup_voice(self):
        """Configura las capacidades de voz"""
        print("\nüé§ Configuraci√≥n de Voz")
        print("=" * 30)
        
        while True:
            try:
                choice = input("¬øHabilitar funcionalidades de voz? (s/n): ").strip().lower()
                
                if choice in ['s', 'si', 's√≠', 'y', 'yes']:
                    print("üé§ Inicializando reconocimiento de voz...")
                    try:
                        self.voice_recognizer = initialize_recognizer()
                        if self.voice_recognizer:
                            print("‚úÖ Reconocimiento de voz activado")
                            return True
                        else:
                            print("‚ö†Ô∏è  No se pudo inicializar el reconocimiento de voz")
                            print("‚ÑπÔ∏è  Continuando sin funcionalidades de voz")
                            return False
                    except Exception as e:
                        print(f"‚ùå Error configurando voz: {e}")
                        print("‚ÑπÔ∏è  Continuando sin funcionalidades de voz")
                        return False
                        
                elif choice in ['n', 'no']:
                    print("‚úÖ Modo sin voz seleccionado")
                    return False
                    
                else:
                    print("‚ùå Respuesta no v√°lida. Usa 's' para s√≠ o 'n' para no.")
                    
            except KeyboardInterrupt:
                print("\nüëã ¬°Hasta luego!")
                exit(0)
    
    async def setup_mcp(self):
        """Configura los servidores MCP"""
        print("\nüîß Configuraci√≥n de MCP (Model Context Protocol)")
        print("=" * 55)
        
        # Detectar directorios existentes para la configuraci√≥n
        home_dir = os.path.expanduser("~")
        possible_dirs = [
            (home_dir, "home"),
            (f"{home_dir}/Documents", "Documents"),
            (f"{home_dir}/Documentos", "Documentos"),
            (f"{home_dir}/Desktop", "Desktop"),
            (f"{home_dir}/Escritorio", "Escritorio"),
            (f"{home_dir}/Descargas", "Descargas"),
            (f"{home_dir}/Downloads", "Downloads"),
            ("/tmp", "temporal")
        ]
        
        # Filtrar solo directorios que existen
        allowed_dirs = []
        for dir_path, description in possible_dirs:
            if os.path.exists(dir_path):
                allowed_dirs.append(dir_path)
                print(f"üìÅ Directorio detectado: {description} ({dir_path})")
        
        if not allowed_dirs:
            print("‚ö†Ô∏è  No se encontraron directorios para MCP filesystem")
            return False
        
        print(f"\n‚úÖ {len(allowed_dirs)} directorios configurados para acceso MCP")
        
        # Configuraci√≥n de servidores MCP
        mcp_config = {
            "filesystem": {
                "command": "npx",
                "args": ["-y", "@modelcontextprotocol/server-filesystem"] + allowed_dirs,
                "transport": "stdio"
            }
        }
        
        print("üöÄ Configurando servidores MCP...")
        success = await self.client.setup_mcp_servers(mcp_config)
        
        if success:
            print("‚úÖ Servidores MCP configurados correctamente")
            return True
        else:
            print("‚ö†Ô∏è  MCP no disponible, continuando sin herramientas de archivos")
            return False
    
    async def run_interactive_mode(self):
        """Ejecuta el modo interactivo"""
        print("\nüó£Ô∏è  Modo Interactivo Activado")
        print("=" * 35)
        print("Comandos disponibles:")
        print("  ‚Ä¢ 'salir' o 'exit' - Terminar")
        print("  ‚Ä¢ 'escuchar' - Entrada por voz (si est√° disponible)")
        print("  ‚Ä¢ 'limpiar' - Limpiar historial")
        print("-" * 50)
        
        while True:
            try:
                # Obtener entrada del usuario
                user_input = input("\nüë§ T√∫: ").strip()
                
                # Comandos especiales
                if user_input.lower() in ['salir', 'exit', 'quit']:
                    print("üëã ¬°Hasta luego!")
                    break
                
                if user_input.lower() in ['limpiar', 'clear']:
                    self.client.conversation_history = []
                    print("üóëÔ∏è  Historial limpiado")
                    continue
                
                if user_input.lower() in ['escuchar', 'listen'] and self.voice_recognizer:
                    print("üé§ Escuchando... (habla ahora)")
                    voice_text = listen_for_command(self.voice_recognizer, timeout=10)
                    if voice_text:
                        user_input = voice_text
                        print(f"üë§ T√∫ (por voz): {user_input}")
                    else:
                        print("üîá No se detect√≥ entrada de voz")
                        continue
                
                if not user_input:
                    continue
                
                # Procesar con el cliente
                print(f"\nü§ñ {self.client.model_type.upper()}:", end=" ")
                await self.client.chat_with_voice(user_input)
                
            except KeyboardInterrupt:
                print("\nüëã ¬°Hasta luego!")
                break
            except Exception as e:
                print(f"‚ùå Error: {e}")
    
    async def main(self):
        """Funci√≥n principal del asistente"""
        print("üåü AURA - Asistente de IA Universal")
        print("Soporte para Gemini, Ollama y MCP")
        print("=" * 50)
        
        try:
            # 1. Configurar modelo
            model_type, model_name = self.setup_model()
            
            # 2. Configurar voz
            enable_voice = self.setup_voice()
            
            # 3. Inicializar cliente
            print(f"\nüöÄ Inicializando cliente {model_type.upper()}...")
            self.client = AuraClient(
                model_type=model_type,
                model_name=model_name,
                enable_voice=enable_voice
            )
            
            # 4. Configurar MCP
            await self.setup_mcp()
            
            # 5. Ejecutar modo interactivo
            await self.run_interactive_mode()
            
        except Exception as e:
            print(f"‚ùå Error cr√≠tico: {e}")
            return 1
        
        return 0

def main():
    """Punto de entrada principal"""
    assistant = AuraAssistant()
    try:
        return asyncio.run(assistant.main())
    except KeyboardInterrupt:
        print("\nüëã ¬°Hasta luego!")
        return 0

if __name__ == "__main__":
    exit(main()) 